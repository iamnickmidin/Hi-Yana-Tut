
## Пояснения к задачам

## Задача 1

Программа считывает строку, в которой могут быть **целые числа**, знаки **`+` и `-`** и **пробелы**.
Если выражение записано правильно — вычисляет его значение. Если есть ошибка — выводит **`ошибка`** и просит ввести строку заново.

---

### 1) Ввод и проверка пустой строки

Считываем строку через `getline`.
Если строка пустая — это ошибка (нет выражения).

---

### 2) Основные переменные

* `result` — итоговая сумма выражения
* `number` — число, которое сейчас читаем
* `sign` — знак текущего числа (`+1` или `-1`)
* `need_number` — флаг: **ждём число** (в начале и после оператора)

---

### 3) Проход по строке посимвольно

Цикл идёт по всем символам строки:

#### Пробелы

Просто пропускаем.

#### Если встретили `+` или `-`

* Если мы *ждём число* (`need_number == true`), то это **унарный знак** (например `-5` или `+7`) → просто меняем `sign`.
* Если мы *уже считали число*, то это **бинарный оператор** → прибавляем прошлое число к результату:
  `result += sign * number`, затем начинаем собирать следующее число.

#### Если встретили цифру

Собираем число:
`number = number * 10 + digit`

Также есть проверка на переполнение `long long`:
если число становится слишком большим, выражение считается неверным.

#### Если встретили любой другой символ

Например `d`, `*`, `.` - сразу ошибка.

---

### 4) Завершение

После цикла:

* Если строка корректная и выражение не заканчивается знаком (`need_number == false`), то прибавляем последнее число к `result` и печатаем ответ.
* Иначе печатаем `ошибка` и просим ввод снова.

---

### Итого:

* поддерживает пробелы,
* поддерживает унарный минус (`-1+2`),
* проверяет корректность записи,
* вычисляет выражение без использования `eval` и без сложных структур.

---

## Задача 2
Пользователь вводит **название текстового файла**, в котором лежат числа.
Дальше программа пробует этот файл открыть:

* если файла **нет** или он не открывается —  **«ошибка»**

Если файл открылся, то:

1. **читает все числа из файла** (сколько бы их ни было),
2. для каждого числа **считает квадрат** (то есть умножает его само на себя),
3. потом **округляет результат до двух цифр после запятой**,
4. и в конце **перезаписывает файл** — вместо старых чисел там уже будут квадраты.

То есть было, например:
`1.1 2.2 3.3 9`

станет:
`1.21 4.84 10.89 81.00`

---
